serialGC
serialGC是单线程GC（这里需要确认，只有一个线程吗？），在GC过程中会发生STW的，使用标记-复制算法用于新生代的垃圾回收，使用标记-移除-整理算法进行老年代的垃圾回收
。由于serialGC在GC时候会暂停所有其他的线程，只保留GC线程进行垃圾回收，所以SerialGC适用于单CPU的机器，serialGC是一个响应速度优先的GC，但是只有单线程进行处理，所以适用于堆内存比较小的环境。
分析：
 使用java -Xmx512m -Xms512m  -XX:-UseAdaptiveSizePolicy -XX:+UseSerialGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps,并加大-Xmx，-Xms发现随着内存加大，gc的次数在减少，但是单次gc的时间增长。并且
老年的使用率随着内存的增大而变的小。但是内存太小也会导致Full GC的频繁。另外值得注意的当不配置Xms时，会增加GC的次数。
parallelGC
parallelGC是并行GC，当进行垃圾收集，会启用多个线程进行处理（线程数可以配置：-XX:ParallelThreads=5）,使用标记-复制算法收集新生代，使用标记标记-清除-整理的算法收集老年代。parallelGC在收集新生代和老年代都会发生STW。
但是parallelGC在STW时间内，是由多个线程并行收集垃圾的，所以每次GC的时间要比serialGC要快。
分析：
   当内存比较小的时候，parallelGC的表现没有SerialGC的表现好，虽然每次GC的时间要比serialGC的时间短，但是GC的次数要大很多。但是随着内存的增加比如1g甚至2g的时候，parallelGC的性能慢慢超过serialGC，但是查看每次垃圾回收的时间差距并不是很大。但是当内存升级到4g～8g时，parallelGC的效果要比SerialGC好很多。但是当内存过大的时候，可以看到每次的GC时间都会增加，0.1秒甚至0.2秒。
CMS
  CMS是一个以减少GC的时间为目标的并发垃圾回收器。在年轻代使用的标记-复制的算法，在老年代使用的是标记-移除算法（由于不进行整理这会减少GC的时间，这会导致内存碎片化，所以会采用空闲列表的方式记录下当前内存空间的使用情况）。并发收集是指cms在进行老年代只会有一小段时间会STW，其他的时间GC线程和业务线程并发执行。CMS就是靠着对老年不进行整理，以及并发（指的是GC线程和业务线程同时操作内存）的执行来减少STW的时间。
  CMS阶段：
        1.初始标记。这个阶段要求STW，这个阶段标记GC root对象以及根对象直接引用的对象。其中根对象包含（1.入参和局部变量。2.活动的线程。3.类的静态参数。4.JNI引用。5.当进行老年代的GC时候，年轻代的对象就会直接成为根对象）
        2.并发标记。这个阶段不会要求STW，GC线程和业务线程同时进行。GC线程会继续遍历标记根对象关联的存活对象，包括年轻代对象引用老年的对象。
        3.并发预处理。这个阶段也不需要STW，是并发处理。这个阶段是对在并发标记阶段，发生了引用关系变化（这里的指的是这些对象引用了新的对象）的区域使用（card 卡片）的方式进行标记为脏区域，这就是卡片标记（card marking）。然后会对这些已经脏对象以及他们引用的对象进行标记，标记完成以后会讲card清掉。
        4.最终标记。这个阶段需要STW，这个阶段会尽量在年轻代空的情况下执行，以免执行更多的STW。
        5.这个阶段将删除没有被标记的对象。
        6.并发重置。重置GC需要的参数，为下一次
分析：
   从日志上看，CMS使用的是ParNewGC处理新生代的垃圾回收，parnewGC是并行的使用标记-复制的算法。并且产看对老年的GC时间，确实CMS的垃圾回收时间要比上面两个GC的STW时间要短。
G1
  G1垃圾回收器被称为（garbage-first）意为垃圾多的优先收集。G1设置的目的是，将GC的时间和分布变得预期而且可以配置（例如：可以配置在1秒的时间内，GC停顿的时间不能超过5ms，G1会尽量保证实现）。G1将不在是直接将内存分为年轻代和老年代，而是将内存分为多个（一般是2048个）可以存储对象的堆小块。每个堆小块都可以被作为eden区，或者survivor区，或者老年区。每次GC时候，不会将所有的区域都进行回收，而是以增量的方式进行（这也减少了GC的时间）。包含所有的年轻代，和一部分的老年代 （被称为回收集）。（有趣的是G1会估算每个堆小块的存活的对象的数量）构建回收集的规则是，垃圾最多的堆小块会优先收集。InitiatingHeapOccupancyPercent（默认45%）用来配置当堆内存占用多少时候会产生G1 触发并发标记。G1垃圾回收器，不在单独对年轻代或者老年代垃圾回收。所以当G1垃圾回收器启动会对年轻代和老年代一同进行回收。
  G1:
    1.暂停转移。这个是对年轻代的模式，当年轻代的内存满了的时候会STW，然后然后将存活的对象拷贝到存活区。（其实这个阶段也将完成下面的初始化标记中对GC Root对象直接引用对象的标记。）
    2.并发标记。这阶段会被分成多个阶段。
      1）.初始化标记。这个阶段完成对GC Root对象可以直接到达对象的标记。
      2）.Root区域扫描。表示存活的堆小块，包括一定会被回收的年轻代的堆小块。完成所有根区域可达的存活对象。
      3）.并发标记。遍历图对象。这个阶段要求线程对象并发的执行更新对对象的应用。舍弃过时引用。
      4）.最终标记。这个阶段会STW。完成未被标记的对象。
      5）.这个阶段也需要一个STW。
      6）.清理阶段。
分析：
  GC日志来看，每次GC在单个STW期间有上下波动，但是整体还是维持在设定的时间范围内。